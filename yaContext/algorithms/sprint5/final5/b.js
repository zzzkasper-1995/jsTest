// Отчет: https://contest.yandex.ru/contest/24810/run-report/109904366/

// Описание задачи: https://contest.yandex.ru/contest/24810/problems/B/

/**
-- ПРИНЦИП РАБОТЫ --
Алгоритм удаления элемента из бинарного дерева поиска включает в себя три основных случая:

Удаление листа (узла без детей): узел просто удаляется, и его родительский узел теперь ссылается на null
Удаление узла с одним ребенком: узел удаляется, и его родитель теперь ссылается на ребенка удаляемого узла
Удаление узла с двумя детьми: в этом случае необходимо найти узел-преемник (максимальный узел в левом поддереве),
переместить его значение в удаляемый узел, а затем удалить узел-преемник

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Корректность алгоритма основывается на свойствах бинарного дерева поиска:
для любого узла все ключи в левом поддереве меньше ключа этого узла, а все ключи в правом поддереве больше
При удалении узла и выборе узла-преемника из его поддерева обеспечивается,
что свойства бинарного дерева поиска сохраняются
Удаление узла-преемника и замена удаляемого узла его значением не нарушает порядка элементов,
поскольку узел-преемник всегда будет находиться в таком месте,
что после его перемещения все узлы дерева сохранили бы правильное отношение друг к другу

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
В худшем случае (когда дерево вырождено в линейный список) удаление узла требует O(n) времени,
где n - количество узлов в дереве, так как может потребоваться пройти от корня до самого глубокого узла.

В среднем случае, при условии, что дерево балансировано, время выполнения будет O(log n), так как глубина балансированного дерева составляет log(n)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Требуется дополнительное пространство для хранения стека вызовов рекурсии,
пространственная сложность составляет O(h), где h - высота дерева.

Для балансированного дерева h = log(n), а для вырожденного дерева h = n
*/

/**
 * Класс узла бинарного дерева
 * @class
 */
class TNode {
    /**
     * @param {*} value - Значение, хранящееся в узле
     * @param {TNode | null} [left=null] - Левый дочерний узел
     * @param {TNode | null} [right=null] - Правый дочерний узел
     */
    constructor(value, left = null, right = null) {
        /** @property {number} value*/
        this.value = value;
        /** 
         * @property {TNode | null} left
         */
        this.left = left;
        /**
         * @property {TNode | null} right
         */
        this.right = right;
    }
}

/**
 * Удаляет узел с указанным ключом из бинарного дерева поиска
 * @param {TNode} node - корень дерева
 * @param {number} key - ключ удаляемого узла
 * @returns {TNode | null} новый корень дерева
 */
function remove(node, key) {
    if (!node) return null;

    // Искомое значение меньше ключа узла
    if (key < node.value) {
        node.left = remove(node.left, key);
    }
    // Искомое значение больше ключа узла
    else if (key > node.value) {
        node.right = remove(node.right, key);
    }
    // Найден узел с искомым значением
    else {
        // Если у этого узла нет детей или только один ребенок
        if (!node.left) return node.right;
        if (!node.right) return node.left;

        // Если у узла два ребенка
        // Находим преемника (p) - минимальный узел в правом поддереве
        let p = findMin(node.right); 
        node.value = p.value;
        // Удаляем узел-преемник с его старого места
        node.right = remove(node.right, p.value); 
    }

    return node;
}

/**
 * Находит минимальный узел в поддереве
 * @param {TNode} node - корень поддерева
 * @returns {TNode}
 */
function findMin(node) {
    while (node.left) {
        node = node.left;
    }

    return node;
}