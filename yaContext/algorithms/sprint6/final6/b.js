// ОТЧЕТ: https://contest.yandex.ru/contest/25070/run-report/111277740/

// Задание: https://contest.yandex.ru/contest/25070/problems/B/?success=111228318#51450/2020_08_18/jFZoIxw68Z

/**
 * -- ПРИНЦИП РАБОТЫ --
 * Алгоритм построения и проверки карты железных дорог реализует направленный граф,
 * где вершины представляют города, а ребра — железные дороги между ними с типами полотна (R или B)
 * Для хранения графа используется список смежности,
 * что позволяет эффективно организовать доступ к соседним вершинам каждого узла
 * Проверка на оптимальность карты осуществляется через метод поиска в глубину (DFS),
 * который использует цвета узлов (белый, серый, черный) для отслеживания их состояния в процессе обхода
 * Белый цвет обозначает непосещенный узел, серый — узел в процессе обхода (находится в стеке вызовов),
 * а черный — полностью обработанный узел
 * Циклы в графе могут указывать на возможность добраться между двумя городами разными типами дорог,
 * что противоречит условию оптимальности карты
 * Поэтому алгоритм проверяет наличие зацикливаний, меняя цвета узлов в процессе DFS.
 * Если во время обхода узел встречается в сером состоянии, это указывает на наличие цикла, и карта считается неоптимальной
 * Такой подход позволяет точно определить, может ли существовать более одного пути между любыми двумя городами,
 * что является критерием оптимальности
 * Применение алгоритма поиска в глубину (DFS) для проверки на зацикливание
 * является классическим подходом в теории графов для определения свойств графовой структуры
 *
 * -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 * Доказательство корректности алгоритма основывается на его способности точно идентифицировать
 * наличие или отсутствие циклов в направленном графе, представляющем карту железных дорог.
 * Ключевым моментом является использование DFS для обхода графа, где цвета узлов (белый, серый, черный)
 * играют важную роль в отслеживании прогресса обхода и обнаружении циклов.
 * Циклы в графе, обнаруживаемые возвращением к узлу, уже находящемуся в обработке (серый),
 * указывают на возможность существования нескольких путей между городами, что противоречит определению оптимальности карты.
 * Также важно, что структура данных графа (список смежности) позволяет точно представлять и
 * эффективно обрабатывать связи между городами, что необходимо для проверки всех возможных путей между каждой парой городов.
 * Отсутствие обнаруженных циклов после полного обхода графа DFS подтверждает,
 * что карта железных дорог соответствует критерию оптимальности, т.е. для любых двух городов существует единственный тип дороги, по которой они соединены.
 * 
 * -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 * Временная сложность алгоритма состоит из двух частей:
 * O(N) для создания графа и O(V + E) для DFS,
 * где N - количество дорог, V - количество городов, E - количество дорог
 * Таким образом, общая временная сложность составляет O(V + E),
 * считая процесс создания графа незначительным
 * 
 * -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 * Пространственная сложность алгоритма O(V + E),
 * так как требуется хранить информацию о каждой вершине и каждом ребре графа
 */


/**
 * Класс для хранения и проверки карты железных дорог
 */
class RailwayMap {
  /** Состояния узла*/
  static NodeColor = {
    WHITE: 'white',
    GRAY: 'gray',
    BLACK: 'black'
  };

  /**
   * Инициализирует карту железных дорог
   * @param {number} numberOfCities - Количество городов
   * @param {string[]} railTypes - Типы железных дорог между городами
   */
  constructor(numberOfCities, railTypes) {
    this.connections = new Array(numberOfCities + 1).fill(null).map(() => []);

    railTypes.forEach((types, index) => {
      types.split('').forEach((type, offset) => {
        const from = index + 1;
        const to = from + offset + 1;
        if (type === 'R') {
          this.connections[from].push(to);
        } else {
          this.connections[to].push(from);
        }
      });
    });
  }

  /**
   * Проверяет, содержит ли граф циклы, используя поиск в глубину (DFS)
   * @param {number} node - Узел для проверки
   * @param {Object} colors - Объект, отслеживающий состояние каждого узла
   * @returns {boolean} Возвращает true, если в графе обнаружен цикл
   */
  detectCycleDFS(node, colors) {
    colors[node] = RailwayMap.NodeColor.GRAY;

    for (const neighbor of this.connections[node]) {
      if (colors[neighbor] === RailwayMap.NodeColor.GRAY || 
         (colors[neighbor] === RailwayMap.NodeColor.WHITE && this.detectCycleDFS(neighbor, colors))) {
        return true;
      }
    }

    colors[node] = RailwayMap.NodeColor.BLACK;

    return false;
  }

  /**
   * Определяет, является ли текущая карта оптимальной
   * @returns {'YES' | 'NO'} Возвращает 'YES', если карта оптимальна, иначе 'NO'
   */
  isOptimal() {
    const colors = new Array(this.connections.length).fill(RailwayMap.NodeColor.WHITE);

    for (let i = 1; i < colors.length; i++) {
      if (colors[i] === RailwayMap.NodeColor.WHITE && this.detectCycleDFS(i, colors)) {
        return 'NO';
      }
    }

    return 'YES';
  }
}

function main(lines) {
  const numberOfCities = parseInt(lines[0], 10);
  const railTypes = lines.slice(1);
  const railwayMap = new RailwayMap(numberOfCities, railTypes);

  console.log(railwayMap.isOptimal());
}

const readline = require("readline");

const reader = readline.createInterface({
  input: process.stdin,
});

const inputLines = [];
let _curLine = 0;

reader.on("line", (line) => {
  inputLines.push(line);
});

process.stdin.on("end", ()=>{
  main(inputLines)
});