// ОТЧЕТ: https://contest.yandex.ru/contest/25597/run-report/111434829/

// Задание: https://contest.yandex.ru/contest/25597/problems/B/?success=111434829#2989/2020_04_29/zDij5o2YCE

/**
 * -- ПРИНЦИП РАБОТЫ --
 * Алгоритм предназначен для проверки возможности разделения списка набранных очков на две группы с равной суммой.
 * В нем используются принципы динамического программирования для определения возможности
 * выбора подмножество очков таким образом, чтобы их сумма составляла ровно половину от общей суммы всех очков.
 * 
 * Предельная сложность алгоритма достаточно большая,
 * поэтому предварительно можно сделать пару быстрых для оптимизации работы
 * 1. Сначала проверяется, является ли общая сумма очков четной - если нет, задача не имеет решения.
 * 2. Затем проверяется, не превышает ли максимальное значение в списке половину общей суммы - если превышает, задача также не имеет решения.
 * 
 * Дальше используется массив (dp),
 * где каждый индексы - это сумма очков от 0 до (сумма очков)/2,
 * значение элемента - это true или false, true - значение достижимо, false - значение не достижимо
 * 
 * Инициализация начинается с ложного значения, кроме нулевого индекса, который устанавливается в истину.
 * Алгоритм перебирает все очки и обновляет массив dp, указывая, можно ли достичь каждой из возможных сумм используя текущее и уже рассмотренные значения очков.
 *
 * -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 * В массиве dp хранится информация о возможности достичь определенной суммы очков с использованием элементов подмножества исходного списка.
 * Базовый случай: dp[0] = true, что обозначает, что сумму 0 очков можно набрать не используя ни одного элемента из списка.
 * 
 * Переход динамики: для каждого нового элемента points[i] обновляем dp[j] = dp[j] || dp[j - points[i]], если j >= points[i].
 * Это отражает, что сумму j можно набрать, если была возможность набрать сумму j - points[i] до добавления элемента points[i].
 * Порядок вычисления: обновление массива dp происходит в обратном порядке, чтобы предотвратить повторное использование одного и того же элемента для достижения суммы.
 * 
 * Ответ на исходный вопрос располагается в dp[halfPointsSum], где halfPointsSum — половина суммы всех очков.
 * Если значение true, значит, существует комбинация чисел, дающая в сумме половину от общей суммы.
 *
 * -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 * Временная сложность алгоритма составляет O(n*sum/2), где n - количество элементов в массиве points, а sum - сумма всех очков.
 * Это следует из необходимости обхода каждого элемента и обновления значений в массиве dp для каждой возможной суммы до sum/2.
 *
 * -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 * Пространственная сложность алгоритма составляет O(sum/2), так как требуется хранить массив dp размером sum/2 + 1, где sum - общая сумма всех очков.
 */

/**
 * 
 * @param {number[]} points - отсортированный список набранных очков
 */
function main(points) {
    let sum = 0
    points.forEach(el => sum += el)

    // если сумма очков не четная, то ее точно нельзя поделить на две равные части
    if(sum % 2 !== 0) {
        return 'False' 
    }

    // Целевая сумма двух равных групп очков
    const halfPointsSum = sum / 2

    // Если максимальный элемент больше чем половина суммы очков, то поделить очки на две равные группы нельзя
    if(points[points.length - 1] > halfPointsSum) {
        return 'False' 
    }

    const matrix = Array(halfPointsSum + 1).fill(false);
    matrix[0] = true;
    for (let i = 0; i < points.length; i++) {
        for (let j = halfPointsSum; j >= points[i]; j--) {
            if (matrix[j - points[i]]) {
                matrix[j] = true;

                if(j === halfPointsSum) {
                    return 'True'
                }
            }
        }
    }

    return matrix[halfPointsSum] ? 'True' : 'False';
}


// Блок ввода/вывода данных
const readline = require('readline');
const io_interface = readline.createInterface({ input: process.stdin });

let lines = [];

io_interface.on('line', function (line) {
    lines.push(line);
});

io_interface.on('close', function () {
    const [_, points]  = lines

    process.stdout.write(main(points.split(' ').map(Number).sort()));
});