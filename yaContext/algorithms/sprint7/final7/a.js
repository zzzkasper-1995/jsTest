// ОТЧЕТ: https://contest.yandex.ru/contest/25597/run-report/111434772/

// Задание: https://contest.yandex.ru/contest/25597/problems/A/


/**
 * -- ПРИНЦИП РАБОТЫ --
 * Алгоритм Вагнера-Фишера для вычисления расстояния Левенштейна основан на динамическом программировании
 * Он вычисляет минимальное количество операций (вставки, удаления, замены),
 * необходимых для преобразования одной строки в другую
 * 
 * Алгоритм использует матрицу для хранения промежуточных результатов вычислений,
 * где каждая ячейка представляет минимальное расстояние между подстроками
 * 
 * 1. Инициализация матрицы: первая строка и первый столбец заполняются числами от 0 до длины соответствующей строки,
 * отражая количество операций для совпадения с пустой строкой
 * 2. Заполнение матрицы: для каждой пары символов из двух строк вычисляется стоимость операций (вставка, удаление, замена),
 и выбирается минимальная из них. Вставка, удаление, замена оцениваются как "1", равенство символов оценивается как "0"
 * 3. Результат алгоритма: значение в правом нижнем углу матрицы отражает минимальное расстояние Левенштейна между двумя строками
 *
 * -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 * Доказательство корректности базируется на принципе оптимальности,
 * согласно которому оптимальное решение для всей задачи включает в себя оптимальные решения для её подзадач - тоесть для решения ее подстрок
 * Матрица заполняется исходя из минимальных известных расстояний для подстрок,
 * что гарантирует нахождение минимального количества операций для преобразования одной строки в другую
 *
 * -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 * Временная сложность алгоритма составляет O(n*m),
 * где n и m - длины строк. Для каждой пары индексов (i, j) выполняется константное количество операций
 *
 * -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 * Пространственная сложность также составляет O(n*m) из-за необходимости хранения матрицы размером n*m,
 * где n и m - длины строк
 * 
 * Однако, можно уменьшить потребление памяти.
 * Так как для вычисления нового значения нам нужны не все предыдущие значения, а только значения предыдущего столбца
 * то по мере вычисления можно ненужные столбцы отчищать,
 * или изначально оперировать только матрицей с двумя столбцами перезаписывая ее значения.
 * 
 * Но текущее решение, также подходит под заданные ограничения по памяти и скорости работы
 */

/**
 * Вычисление расстояние Левенштейна методом Вагнера — Фишера
 * @param {string} _str1
 * @param {string} _str2
 */
function main(_str1, _str2) {
    /** Так как максимальное расстояние соответствует длине наибольшей строки,
    то для удобства сделаем строками матрицы символы самой длинной строки **/
    let str1 = _str1
    let str2 = _str2
    if(_str1.length > _str2.length) {
        str1 = _str2
        str2 = _str1
    }

    /** Подготавливаем матрицу */
    const matrix = new Array(str1.length + 1)
        .fill(undefined)
        .map(() => new Array(str2.length + 1).fill(undefined))
    for(let i = 0; i < str1.length + 1; i++) {
        matrix[i][0] = i
    }
    for(let j = 0; j < str2.length + 1; j++) {
        matrix[0][j] = j
    }

    for(let i = 0; i < str1.length; i++) {
        for(let j = 0; j < str2.length; j++) {
            const symb1 = str1[i]
            const symb2 = str2[j]

            matrix[i+1][j+1] = Math.min(
                // Если нужно удалить символ
                matrix[i][j+1] + 1,
                // Если нужно добавить символ, то увеличиваем длину на 1
                matrix[i+1][j] + 1,
                // Если нужно заменить символ или если символы равны
                matrix[i][j] + (symb1 === symb2 ? 0 : 1)
            )
        }
    }

    return matrix[str1.length][str2.length]
}


// Блок ввода/вывода данных
const readline = require('readline');
const io_interface = readline.createInterface({ input: process.stdin });

let lines = [];

io_interface.on('line', function (line) {
    lines.push(line);
});

io_interface.on('close', function () {
    const [str1, str2]  = lines

    console.log(main(str1, str2));
});