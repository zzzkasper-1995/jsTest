// ОТЧЕТ: https://contest.yandex.ru/contest/26133/run-report/111563967/

// Задача: https://contest.yandex.ru/contest/26133/problems/A/?success=111563967#51450/2020_07_22/Lxm8FGkQIC

/**
 * -- ПРИНЦИП РАБОТЫ --
 * Алгоритм нахождения наибольшего общего префикса среди массива строк основан на последовательном сравнении символов каждой строки.
 * 1. Как основу для префикса изначально берем первую строку массива.
 * 2. Сравнение строк: алгоритм последовательно перебирает остальные строки массива, сравнивая символы текущего префикса с символами из этих строк.
 * 3. Обновление префикса: при обнаружении первого несовпадения символов, префикс обновляется до текущей позиции совпадения.
 * 4. Прекращение работы: если в какой-то момент префикс становится пустым, алгоритм прекращает работу, так как дальнейшее сравнение не имеет смысла.
 *
 * -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 * Алгоритм гарантирует нахождение наибольшего общего префикса за счёт пошагового сужения диапазона поиска (максимальная длина префикса).
 * На каждом шаге префикс уменьшается только в случае несовпадения символов, что обеспечивает его актуальность для всех рассмотренных строк.
 * Если для какой-то строки префикс не обновляется, значит он уже является максимально возможным общим префиксом для всех предыдущих и текущей строки.
 * Таким образом, по завершению работы алгоритма, последний актуальный префикс и будет наибольшим общим префиксом.
 *
 * -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 * Пусть n - среднее количество символов в строках, k - количество строк, тогда N - это общее количество всех символов в строках.
 * Тогда наихудший случай временной сложности алгоритма - O(N).
 * Это происходит, когда алгоритму приходится сравнивать большинство символов из каждой строки до обнаружения несовпадения или до конца строк,
 * например если строки имеют одинаковое начало
 *
 * -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 * Алгоритм требует O(1) дополнительной памяти, за исключением памяти, необходимой для хранения входных данных.
 * Весь процесс сравнения и обновления префикса происходит на месте,
 * без необходимости выделения дополнительного пространства для других структур данных.
 */


/**
 * Проверяет, является ли символ числом
 * @param {string} symbol Символ для проверки
 * @returns {boolean} Возвращает true, если символ - число, иначе false
 */
function isDigit(symbol) {
  const number = parseInt(symbol, 10);
  return !isNaN(number) && number.toString() === symbol;
}

/**
 * Преобразует ЗС (запакованную строку) в обычную строку
 * @param {string} packStr Строка для распаковки
 * @returns {string} Распакованная строка
 */
function unpackString(packStr) {
  // Стек для учета текущего уровня вложенности и накопления результата
  let stack = [{ repeat: 1, result: "" }];

  for (let i = 0; i < packStr.length; i++) {
    if (isDigit(packStr[i])) {
      stack.push({ repeat: Number(packStr[i]), result: "" });
    } else if (packStr[i] === "[") {
      continue
    } else if (packStr[i] === "]") {
      // Когда встречаем закрывающую скобку, снимаем верхний элемент стека
      const { repeat, result } = stack.pop();
      stack[stack.length - 1].result += result.repeat(repeat);
    } else {
      /** Если текущий символ - не скобка и не число,
      добавляем его к результату верхнего элемента стека */
      stack[stack.length - 1].result += packStr[i];
    }
  }

  return stack[0].result;
}

/**
 * Определяет наибольший общий префикс для массива распакованных строк
 * @param {string[]} strings Массив строк для обработки
 * @returns {string} Наибольший общий префикс
 */
function main(strings) {
  let prefix = unpackString(strings[0]);

  for (let i = 1; i < strings.length; i++) {
    // Распаковываем каждую строку и сравниваем ее с текущим префиксом
    const expanded = unpackString(strings[i]);
    let lastPrefixIndex = 0;
    for (let j = 0; j < prefix.length && j < expanded.length; j++) {
      if (expanded[j] !== prefix[j]) {
        // Обновляем префикс при первом несовпадении
        break;
      }

      lastPrefixIndex = j + 1;
    }

    prefix = prefix.substring(0, lastPrefixIndex);

    // Если префикс стал пустым, прерываем цикл
    if (prefix === "") break;
  }

  return prefix;
}

// Блок ввода/вывода данных
const readline = require('readline');
const io_interface = readline.createInterface({ input: process.stdin });

let lines = [];

io_interface.on('line', function (line) {
    lines.push(line);
});

io_interface.on('close', function () {
    const [_, ...strings]  = lines

    console.log(main(strings));
});
