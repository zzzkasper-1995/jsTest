// Отчет: https://contest.yandex.ru/contest/26133/run-report/111585273/

// Задание: https://contest.yandex.ru/contest/26133/problems/B/?success=111584126#51450/2020_07_21/q5eMaCPDPy

/**
 * -- ПРИНЦИП РАБОТЫ --
 * Алгоритм использует структуру данных Trie для эффективного хранения и поиска слов.
 * Trie представляет собой дерево, где каждый узел соответствует символу слова,
 * а путь от корня к узлу представляет слово или его префикс.
 * 
 * Алгоритм работает следующим образом:
 * 1) Инициализация Trie: На основе предоставленного словаря слов создается префиксное дерево.
 * Каждое слово добавляется в дерево, так что каждый символ слова представлен узлом в дереве.
 * 
 * 2) Разбиение строки: Алгоритм проходит по строке, пытаясь найти слова из словаря, начиная с каждой возможной позиции.
 * Для этого он использует множество для отслеживания позиций в строке, с которых может начинаться слово.
 * Поиск слов: Начиная с каждой позиции, алгоритм идет по символам строки и соответствующим узлам в Trie,
 * проверяя, можно ли из текущей позиции сформировать слово.
 * Если да, то позиция, следующая за найденным словом, добавляется в множество возможных начал слов
 * 
 * 3) Проверка возможности разбиения: Строка считается успешно разбитой на слова,
 * если конец строки достигается d trie,
 * то есть последний символ строки является концом какого-либо слова в Trie
 * 
 * -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 * Алгоритм проверяет все возможные способы разбиения строки на слова из словаря.
 * Использование структуры данных Trie гарантирует, что любое слово, которое можно сформировать из подстроки, будет найдено.
 * Механизм отслеживания начал слов с помощью множества обеспечивает,
 * то что алгоритм не пропустит ни одной возможности начать новое слово.
 * 
 * -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 * Временная сложность алгоритма зависит от длины строки (S) и максимальной длины высоты дерева в trie (M - максимальная длина слова).
 * Инициализация Trie происходит за O(W), где W — общая длина всех слов в словаре.
 * 
 * Проверка разбиения строки требует прохода по каждому символу строки и поиска соответствующего пути в Trie,
 * что в худшем случае может занять O(S*M), если учитывать,
 * что каждый новый символ может потенциально быть началом нового слова
 * 
 * -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 * Пространственная сложность алгоритма в зависит от размера Trie и количества позиций кандидатов в строке на начало слова 
 * 
 * Для хранения Trie требуется O(W) памяти, где W — общая длина всех слов в словаре.
 * Множество возможных начал слов требует в худшем случае O(S) памяти, где S — длина входной строки.
 * Следовательно, общая пространственная сложность составляет O(W + S).
 */

class TrieNode {
    constructor(value, isWordEnd = false) {
      this.value = value;
      this.children = {};
      this.isWordEnd = false; // Флаг, указывающий на конец слова
    }
}
  
  
class Trie {
    constructor(words = []) {
      this.root = new TrieNode('', true);

      words.forEach(word => this.addWord(word));
    }
  
    /**
     * Добавляет слово в структуру данных Trie
     * @param {string} word Слово для добавления
     */
    addWord(word) {
      let node = this.root;
      for (let i = 0; i < word.length; i++) {
        const letter = word[i];
        if (!node.children[letter]) {
          node.children[letter] = new TrieNode(letter);
        }
        
        node = node.children[letter];
      }
  
      node.isWordEnd = true;
    }
  }
  
  /**
   * Проверяет, возможно ли разбить строку на слова из заданного набора
   * @param {string} str Строка для разбиения
   * @param {string[]} dictionary Словарь слов
   * @returns {boolean} Возможно или нет
   */
/**
 * Проверяет, возможно ли разбить строку на слова из заданного набора
 * @param {string} str Строка для разбиения
 * @param {string[]} dictionary Словарь слов
 * @returns {boolean} Возможно или нет разбить строку на слова
 */
function isDecomposable(str, dictionary) {
    const trie = new Trie(dictionary);
    let currentNode = trie.root;
  
    // Используем Set для отслеживания индексов, которые могут быть началом слова
    // Начало строки всегда может быть началом слова
    const possibleStarts = new Set([0]); 
  
    for (let n = 0; n < str.length; n++) {
      if (!possibleStarts.has(n)) {
        // Если текущая позиция не может быть началом слова, пропускаем её
        continue; 
      }
  
      
    //   Начиная с позиции которая может быть началом слова,
    //   ищем всевозможные слова которые могут быть префиксом дальнейшей подстроки
      currentNode = trie.root;
      for (let i = n; i < str.length; i++) {
        const currentChar = str[i];
        if (!currentNode.children[currentChar]) {
          // Не нашли подходящее продолжение слова
          break; 
        }
  
        currentNode = currentNode.children[currentChar];
        if (currentNode.isWordEnd) {
          // Если достигли конца слова, добавляем следующий индекс как возможное начало следующего слова
          possibleStarts.add(i + 1);
        }
      }
    }
  
    // Если последняя позиция может быть началом слова, значит вся строка разбита корректно
    return possibleStarts.has(str.length);
  }
  

  function main(textline, words) {
    return isDecomposable(textline, words) ? "YES" : "NO"
  }
  
  // Блок ввода/вывода данных
  const readline = require('readline');
  const io_interface = readline.createInterface({ input: process.stdin });
  
  let lines = [];
  
  io_interface.on('line', function (line) {
      lines.push(line);
  });
  
  io_interface.on('close', function () {
      const [textline, _, ...words]  = lines
  
      console.log(main(textline, words));
  });